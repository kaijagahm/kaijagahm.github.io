{
  "hash": "7c923a41d7731344437cabdd797c88c6",
  "result": {
    "markdown": "---\ntitle: \"If ifelse() had more if's (case_when(), part 1)\"\ndescription: \"In which I discover dplyr's case_when() function, a vectorized version of ifelse().\"\nauthor:\n  - name: Kaija Gahm\n    url: https://kaijagahm.github.io\n    orcid: 0000-0002-4612-4426\n    affiliation: Yale University\ndate: 10-11-2019\nimage: colorSorter.jpg\ncategories: [R, tidyverse] # self-defined categories\ncitation: \n  url: https://kaijagahm.github.io/posts/2019-10-11-if-ifelse-had-more-ifs\ndraft: false\n---\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Source: Interesting Engineering (https://interestingengineering.com/video/make-your-very-own-arduino-based-color-candy-sorting-machine)](colorSorter.jpg){width=372}\n:::\n:::\n\n\n*This post has been modified from its original form on [woodpeckR](https://thewoodpeckr.wordpress.com/2019/10/11/if-ifelse-had-more-ifs/).*\n\n### Problem\n\nThe `ifelse()` function only allows for one “if” statement, and therefore two cases. You could add nested “if” statements, but that’s just a pain, especially if the 3+ conditions you want to use are all equivalent, conceptually. Is there a way to specify multiple conditions at the same time?\n\n### Context\n\nI was recently given some survey data to clean up. It looked something like this (but obviously much larger):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(name = c(\"Kaija\", \"Ella\", \"Andis\"),\n                  test1 = c(FALSE, TRUE, TRUE),\n                  test2 = c(FALSE, FALSE, TRUE))\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name test1 test2\n1 Kaija FALSE FALSE\n2  Ella  TRUE FALSE\n3 Andis  TRUE  TRUE\n```\n:::\n:::\n\n\nI needed to classify people in this data set based on whether they had passed or failed certain tests.\n\nI wanted to separate the people into three groups:\n\n**People who passed both tests:** Group A\n\n**People who passed one test:** Group B\n\n**People who passed neither test:** Group C\n\nI thought about using a nested `ifelse()` statement, and I certainly could have done that. But that approach didn’t make sense to me. The tests are equivalent and not given in any order; I simply want to sort the people into three equal groups. Any nesting of “if” statements would seem to imply a hierarchy that doesn’t really exist in the data. Not to mention that I don't usually like nesting functions--I find it confusing and hard to read. \n\n### Solution\n\nOnce again, `dplyr` to the rescue! I’m becoming more and more of a tidyverse fan with each passing day. \n\nTurns out, `dplyr` has a function for exactly this purpose: `case_when()`. It’s also known as “a general vectorised if,” but I like to think of it as “if ifelse() had more if’s.” \n\nHere’s the syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr) # load dplyr\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\ndat <- dat %>% # using the dplyr/magrittr pipe\n  mutate(grp = case_when(test1 & test2 ~ \"A\", # both tests: group A\n                         xor(test1, test2) ~ \"B\", # one test: group B\n                         !test1 & !test2 ~ \"C\" # neither test: group C\n  ))\n\n# Show the result:\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name test1 test2 grp\n1 Kaija FALSE FALSE   C\n2  Ella  TRUE FALSE   B\n3 Andis  TRUE  TRUE   A\n```\n:::\n:::\n\n\nLet me translate the above into English:\n\nAfter loading the package, I reassign `dat`, my data frame, to a modified version of the old `dat`. Then (`%>%`), I use the `dplyr::mutate` function to add a new column called `grp`. The contents of the column will be defined by the `case_when()` function.\n\n`case_when()`, in this example, took three conditions. The condition is on the left side of the ~, and the resulting group assignment (in my case, A, B, or C) is on the right. \n\nI used logical operators for my conditions. The newest one to me was the `xor()` function, which is an *exclusive or*: only one of the conditions in the parentheses can be `TRUE`, not both. \n\n### Outcome\n\nEasily make conditional assignments within a data frame. This function is a little less succinct than `ifelse()`, so I’m probably not going to use it for applications with only two cases, where `ifelse()` would work fine. But for three or more cases, it can’t be beat. Notice that I could have added any number of conditions to my `case_when() statement`, with no other caveats.\n\nI love this function, and I think we should all be using it.\n\n*NOTE: `case_when()` has some tricky behavior when it comes to cases you don't explicitly assign to an outcome. That is to say, the `else` part of this vectorized `ifelse` function is a little confusing. I discuss the `else` more in the next installment of this post.*",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}