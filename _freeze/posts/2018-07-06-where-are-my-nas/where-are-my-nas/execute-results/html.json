{
  "hash": "4dc4e2be454284262c7ce6bfd55e86cd",
  "result": {
    "markdown": "---\ntitle: \"Where are my NA's?\"\ndescription: |\n  I wrote a function to summarize how many NA's are in each column of a data frame. Preview image by Allison Horst, https://github.com/allisonhorst.\nauthor:\n  - name: Kaija Gahm\n    url: {}\ndate: 07-06-2018\noutput:\n  distill::distill_article:\n    self_contained: false\n    highlight: kate\npreview: naniar.jpg\n---\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Artwork by Allison Horst, https://github.com/allisonhorst/stats-illustrations.](naniar.jpg){width=790}\n:::\n:::\n\n\n*This post has been slightly modified from its original form on [woodpeckR](https://thewoodpeckr.wordpress.com/2018/07/06/the-journey-begins/).*\n\n### Problem\n\nHow can I (quickly and intuitively) figure out how many `NA`’s are in my dataset and which columns they’re in?\n\n### Context\n\nWhen I tried to run PCA (Principal Components Analysis) on some USGS fish sampling data, I noticed that I had a bunch of missing values. PCA needs complete observations, so this was a problem.\n\nOne option would have been to remove any observations with missing values from my data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select only \"complete\" rows from the data frame `df`  \n# noNAs <- df[complete.cases(df),]\n```\n:::\n\n\nThe problem was, I had over 30 variables and who knows how many missing values. The data frame had only ~2000 observations. By using only complete cases, I might lose a lot of observations and reduce my sample size by a huge amount.\n\nIn fact, I pretty often find myself in this situation. It would be really nice to have a quick way to see where those `NA` values are located so I can get a better sense of my dataset and figure out how to move forward.\n\n### Solution\n\nWrite a loop that tells us how many `NA`’s are in each column.\n\nFirst, let’s create a sample data frame and call it `sample.df`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the data frame\nsample.df <- data.frame(\n     site = 1:4, \n     temp = c(10, 15, 13, NA), \n     depth = c(1.1, NA, 2.0, NA)\n)\n\n# Show the data frame\nsample.df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site temp depth\n1    1   10   1.1\n2    2   15    NA\n3    3   13   2.0\n4    4   NA    NA\n```\n:::\n:::\n\n\nLoop through the columns and print out the number of `NA`’s:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector full of NA's, the same length as the number of columns in sample.df\nna.vec <- rep(NA, ncol(sample.df))\n\n# Loop through the columns and fill na.vec\nfor(i in 1:ncol(sample.df)){\n     na.vec[i] <- sum(is.na(sample.df[,i]))\n}\n\n# Take a look at na.vec\nna.vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 2\n```\n:::\n:::\n\n\nNow we can see that there are 0 `NA`’s in the first column, 1 `NA` in the second column, and 2 `NA`’s in the third column.\n\nBut if you have 30 columns, it’s a pain to map those numbers to the column names. So let’s do better. Instead of just printing the numbers of `NA`’s in a vector, we’ll put them in a data frame along with the names of the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame\nna.df <- data.frame(\n     Column = names(sample.df),\n     num.nas = NA\n)\n\n# Loop through the columns of sample.df and fill na.df\nfor(i in 1:ncol(sample.df)){\n     na.df$num.nas[i] <- sum(is.na(sample.df[,i]))\n}\n\n# Take a look at na.df\nna.df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Column num.nas\n1   site       0\n2   temp       1\n3  depth       2\n```\n:::\n:::\n\n\nSo much better!\n\nOnce you get used to it, this is a quick loop to write. But I got sick of re-creating this process every time, so I wrote a function called locate.nas. Feel free to use it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Locate NA's: produces a data frame with column names and number of na's\nlocate.nas <- function(df){\n  na.df <- data.frame(\n    colname = names(df),\n    nas = NA\n  )\n  \n  for(i in 1:ncol(df)){\n    na.df$nas[i] <- sum(is.na(df[,i]))\n  }\n  return(na.df)\n}\n```\n:::\n\n\n### Outcome\n\nA quick look at the distribution of missing values (`NA`’s) in my data frame turned up an obvious pattern. I checked the sampling protocol and saw that certain variables had only been measured for lotic areas (moving water), while others had only been measured for lentic areas (still water). Since every observation point was in either a lotic or a lentic area, filtering out incomplete observations would have left me with no data at all.\n\nBy adding an indicator variable for lotic/lentic area, I could sort out my data and run PCA separately. Or I could remove the variables measured for only one area. Problem solved.\n\n### Resources\n- [`locate_nas` function](https://raw.githubusercontent.com/kaijagahm/general/master/locate.nas.txt)\n\n- There's also a whole package that makes dealing with NA's easier. I didn't know about it when I originally wrote this post, but I've since discovered it, and you should check it out! It's called `naniar`, and you can find it [here](https://cran.r-project.org/web/packages/naniar/vignettes/getting-started-w-naniar.html)\n\n\n\n",
    "supporting": [
      "where-are-my-nas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}