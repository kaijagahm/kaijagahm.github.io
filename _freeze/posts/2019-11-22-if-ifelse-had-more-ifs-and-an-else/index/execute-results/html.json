{
  "hash": "07e7ae5dd6655eed43d3cdff9ab7236a",
  "result": {
    "markdown": "---\ntitle: \"If ifelse() had more if's (case_when(), part 2)\"\ndescription: \"In which I learn how to make case_when() behave like a true if/else, including the else part. What happens when you only want to assign particular outcomes to a few cases, without touching the rest? Or if you want to bulk-assign all the unspecified cases to one outcome? The syntax is weird, but it works.\"\nauthor:\n  - name: Kaija Gahm\n    url: https://kaijagahm.github.io\n    orcid: 0000-0002-4612-4426\n    affiliation: Yale University\ndate: 11-22-2019\nimage: colorSorter.jpg\ncategories: [R, tidyverse] # self-defined categories\ncitation: \n  url: https://kaijagahm.github.io/posts/2019-11-22-if-ifelse-had-more-ifs-and-an-else\ndraft: false\n---\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Source: Interesting Engineering (https://interestingengineering.com/video/make-your-very-own-arduino-based-color-candy-sorting-machine)](colorSorter.jpg){width=372}\n:::\n:::\n\n\n*This post has been modified from its original form on [woodpeckR](https://thewoodpeckr.wordpress.com/2019/11/22/if-ifelse-had-more-ifs-and-an-else/).*\n\n### Problem\n\nLast month, I was super excited to discover the `case_when()` function in `dplyr`. But when I showed my blog post to a friend, he pointed out a problem: there seemed to be no way to specify a “background” case, like the “else” in ifelse(). \n\n\n::: {.cell}\n::: {.cell-output-display}\n![Michael isn't satisfied with my description of case_when().](michaelMessage.png){width=458}\n:::\n:::\n\n\nIn the previous post, I gave an example with three outcomes based on test results. The implication was that there would be roughly equal numbers of people in each group. But what if the vast majority of people failed both tests, and we really just wanted to filter out the ones who didn’t?\n\n### Context\n\nLet's say I'm analyzing morphometric data for the penguins in the [Palmer Penguins dataset](https://allisonhorst.github.io/palmerpenguins/articles/intro.html). I conduct a principal components analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the penguins data\nlibrary(palmerpenguins)\nlibrary(dplyr) # for pipe and case_when and mutate etc.\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(tibble) # for rownames_to_column\nlibrary(ggplot2) # for plotting\n\n# Conduct Principal Components Analysis (PCA)\npca <- prcomp(~bill_length_mm + bill_depth_mm + \n                flipper_length_mm + body_mass_g, data = penguins)\n\n# Label pca score rows to prepare for join with penguins.\ncomponents <- pca$x %>% \n  as.data.frame() %>%\n  rownames_to_column(\"id\")\n\n# Join pca scores to penguins\npenguins <- penguins %>%\n  rownames_to_column(\"id\") %>% \n  left_join(components, by = \"id\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Take a peek at the data:\npenguins %>%\n  as.data.frame() %>%\n  head() # now the PC scores are joined onto the penguins data, so I can use it in plotting.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id species    island bill_length_mm bill_depth_mm flipper_length_mm\n1  1  Adelie Torgersen           39.1          18.7               181\n2  2  Adelie Torgersen           39.5          17.4               186\n3  3  Adelie Torgersen           40.3          18.0               195\n4  4  Adelie Torgersen             NA            NA                NA\n5  5  Adelie Torgersen           36.7          19.3               193\n6  6  Adelie Torgersen           39.3          20.6               190\n  body_mass_g    sex year       PC1       PC2         PC3        PC4\n1        3750   male 2007 -452.0232 13.336636 -1.14798019 -0.3534919\n2        3800 female 2007 -401.9500  9.152694  0.09037342 -1.0483310\n3        3250 female 2007 -951.7409 -8.261476  2.35184450  0.8417657\n4          NA   <NA> 2007        NA        NA          NA         NA\n5        3450 female 2007 -751.8127 -1.975922  4.81117040  2.1800839\n6        3650   male 2007 -551.8746  3.343783  1.11849344  2.7060578\n```\n:::\n:::\n\n\nAfter running the PCA, I make a plot of the 2nd and 3rd principal components that looks like this: \n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nBefore continuing my analysis, I wanted to take a closer look at a few points that look like they might be outliers. Specifically, I'm interested in the Adelie point that has a PC2 value greater than 20, and the Chinstrap point that has a PC3 value less than -15. I'm also *slightly* worried about the two points that have a PC2 value below -15, but they aren't quite as far out, so I want to classify them separately.\n\nTo figure out which penguins to look at in the data, I will have to pull out rows based on their scores on the PC2 and PC3 axes.\n\n### Solution\n\nI decide to add a column called `investigate` to my data, set to either 'investigate', 'maybe' or 'no' depending on whether the observation in question needs to be checked.\n\nThis is a great use for my new friend `case_when()`! I'll approach it like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- penguins %>%\n  mutate(investigate = case_when(PC2 > 20 | PC3 < -15 ~ \"investigate\",\n                                 PC2 < -15 ~ \"maybe\",\n                                 TRUE ~ \"no\"))\n```\n:::\n\n\nWhat’s up with that weird `TRUE ~ \"no\"` line at the end of the `case_when()` statement? Basically, the `TRUE` is the equivalent of an `else`. It translates, roughly, to \"assign anything that’s left to 'no.'\"\n\n#### Why 'TRUE', not 'else'?\nI don't love the choice of TRUE here--I think the syntax is pretty confusing, and it's something I had to memorize long before I understood the logic behind it.\n\nBasically, `case_when()` works by checking each of your 'cases' (conditions, if-statements) in order. For each row of the data frame, it checks the first case, and applies the resulting assignment if the row meets that case. If the row does *not* meet the first case, the function moves on to the second case, then the third, and on and on until it finds a case that evaluates to `TRUE` for that row.\n\nSo, when you want to write an \"else\" condition, you write `TRUE` as a catchall. `TRUE` will always evaluate to `TRUE`, so all rows that are left over after failing the first however many conditions will all \"pass\" that last condition and will be assigned to your desired \"else\" value. \n\nBecause of this, order matters! If I had started off with the TRUE ~ \"ok\" statement and then specified the other conditions, my code wouldn’t have worked: everything would just get assigned to “no”.\n\n#### The dark side of the `TRUE` condition\n\nYou might be wondering what would happen if we omitted the `TRUE` condition. In [part 1 of my case_when() explanation](https://kaijagahm.github.io/posts/2019-10-11-if-ifelse-had-more-ifs)\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}