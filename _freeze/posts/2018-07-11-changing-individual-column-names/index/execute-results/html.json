{
  "hash": "a044f44320ffde02712f0a54c3578d1d",
  "result": {
    "markdown": "---\ntitle: \"Changing individual column names\"\ndescription: \"How to rename individual columns in a data frame, based on the previous names and without using previous names.\"\nauthor:\n  - name: Kaija Gahm\n    url: https://kaijagahm.github.io\n    orcid: 0000-0002-4612-4426\n    affiliation: Yale University\ndate: 07-11-2018\ncategories: [R] # self-defined categories\ncitation: \n  url: https://kaijagahm.github.io/posts/2018-07-11-changing-individual-column-names\ndraft: false\n---\n\n\n\n\n*This post has been slightly modified from its original form on [woodpeckR](https://thewoodpeckr.wordpress.com/2018/07/12/changing-individual-column-names/).*\n\n### Problem\n\nHow do I change the name of just one column in a data frame?\n\n### Context\n\nThis is a simple one that keeps coming up. Sometimes, whoever put together my data decided to capitalize the first letter of some column names and not others. Sometimes I've merged several data frames together and I need to distinguish the columns from each other.\n\nSay my data frame is `p8_0` and I'd like to change the column `Area` to `area`.\n\nIn the past, I've done this in one of two ways. Either I change all of the column names at once (if all of them need to be changed), or I use numerical column indexing. The latter makes a lot more sense if I have a lot of columns to deal with, but it means I have to know the number of the column whose name I have to change.\n\nTo find this out, I first have to look at all of the column names. Okay, no problem.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# See column names and numerical indices\nnames(p8_0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] \"FID\"                     \"Join_Count\"             \n  [3] \"TARGET_FID\"              \"Field1\"                 \n  [5] \"barcode\"                 \"stratum\"                \n  [7] \"lcode\"                   \"sdate\"                  \n  [9] \"utm_e\"                   \"utm_n\"                  \n [11] \"snag\"                    \"OBJECTID\"               \n [13] \"uniq_id\"                 \"aa_num\"                 \n [15] \"AQUA_CODE\"               \"AQUA_DESC\"              \n [17] \"pool\"                    \"Area\"                   \n [19] \"Perimeter\"               \"bath_pct\"               \n [21] \"max_depth\"               \"avg_depth\"              \n [23] \"sd_depth\"                \"tot_vol\"                \n [25] \"area_gt50\"               \"area_gt100\"             \n [27] \"area_gt200\"              \"area_gt300\"             \n [29] \"avg_fetch\"               \"shoreline_density_index\"\n [31] \"econ\"                    \"sill\"                   \n [33] \"min_rm\"                  \"max_rm\"                 \n [35] \"len_met\"                 \"len_prm_lotic\"          \n [37] \"pct_prm_lotic\"           \"num_lotic_outl\"         \n [39] \"len_prm_lentic\"          \"pct_prm_lentic\"         \n [41] \"num_lentic_outl\"         \"pct_aqveg\"              \n [43] \"pct_opwat\"               \"len_terr\"               \n [45] \"pct_terr\"                \"pct_aq\"                 \n [47] \"len_wetf\"                \"pct_prm_wetf\"           \n [49] \"pct_terr_shore_wetf\"     \"len_wd\"                 \n [51] \"wdl_p_m2\"                \"num_wd\"                 \n [53] \"scour_wd\"                \"psco_wd\"                \n [55] \"len_revln\"               \"rev_p_m2\"               \n [57] \"num_rev\"                 \"pct_terr_shore_rev\"     \n [59] \"pct_prm_rev\"             \"area_tpi1\"              \n [61] \"pct_tpi1\"                \"area_tpi2\"              \n [63] \"pct_tpi2\"                \"area_tpi3\"              \n [65] \"pct_tpi3\"                \"area_tpi4\"              \n [67] \"pct_tpi4\"                \"sinuosity\"              \n [69] \"year_phot\"               \"NEAR_TERR_FID\"          \n [71] \"NEAR_TERR_DIST\"          \"NEAR_TERR_CLASS_31\"     \n [73] \"NEAR_TERR_CLASS_15\"      \"NEAR_TERR_CLASS_7\"      \n [75] \"NEAR_TERR_CLASS_31_N\"    \"NEAR_TERR_CLASS_15_N\"   \n [77] \"NEAR_TERR_CLASS_7_N\"     \"NEAR_TERR_HEIGHT_N\"     \n [79] \"NEAR_FOREST_FID\"         \"NEAR_FOREST_DIST\"       \n [81] \"NEAR_FOREST_CLASS_31\"    \"NEAR_FOREST_CLASS_15\"   \n [83] \"NEAR_FOREST_CLASS_7\"     \"NEAR_FOREST_CLASS_31_N\" \n [85] \"NEAR_FOREST_CLASS_15_N\"  \"NEAR_FOREST_CLASS_7_N\"  \n [87] \"NEAR_FOREST_HEIGHT_N\"    \"year.p\"                 \n [89] \"depth.p\"                 \"current.p\"              \n [91] \"gear.p\"                  \"stageht.p\"              \n [93] \"substrt.p\"               \"wingdike.p\"             \n [95] \"riprap.p\"                \"trib.p\"                 \n [97] \"snagyn\"                  \"area_le50\"              \n [99] \"area_le100\"              \"area_le200\"             \n[101] \"area_le300\"              \"pct_area_le100\"         \n[103] \"pct_area_le50\"           \"pct_area_le200\"         \n[105] \"pct_area_le300\"          \"stratum_name\"           \n```\n:::\n:::\n\n\nOkay, yes problem.\n\nIt’s not that hard to see that `Area` is the 18th column. But there are a bunch of columns that start with `NEAR_TERR_` and `NEAR_FOREST_` that would be easy to confuse. And what if I later modify my data cleaning script, insert new columns, and mess up the numerical indexing?\n\n### Solution\n\nThe first solution I came up with is simple but pretty clunky. At least it solves the problem of numerical indices getting misaligned. And if you mistype the column name or try to change the name of a column that doesn’t exist, it doesn’t throw an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change \"Area\" column name to \"area\"\nnames(p8_0)[names(p8_0) == \"Area\"] <- \"area\"\n```\n:::\n\n\nThis works well, but it gets annoying if you have more than one column name to change. Every column requires typing `names(p8_0)` twice, and that adds up to a lot of lines of code.\n\nTo no one’s surprise, `dplyr` has a more elegant solution, using the `rename` function.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load dplyr \nlibrary(dplyr) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\n# Rename variable (new name first) \np8_0 <- p8_0 %>% \n  rename(area = Area)\n```\n:::\n\n\nA quick note on rename: somewhat counterintuitively, the new name comes before the old name. General example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# General syntax for rename \n#df %>% \n#  rename(newname = oldname)\n```\n:::\n\n\n`rename` saves a whole bunch of keystrokes and also scales very well to multiple columns.\n\nLet’s say I wanted to change `Area` and `Perimeter` to `area` and `perimeter`, respectively, and I also wanted to change the rather clunky `shoreline_density_index` to `sdi.` And while we’re at it, `snagyn`, a factor variable that indicates whether a large piece of wood was present at the site (“yes” or “no”), might be clearer as `snag_yn`, and `sinuosity` could be shortened to `sinu`\n\nWithout `dplyr`:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change each column name individually\nnames(p8_0)[names(p8_0) == \"Area\"] <- \"area\"\nnames(p8_0)[names(p8_0) == \"Perimeter\"] <- \"perimeter\"\nnames(p8_0)[names(p8_0) == \"shoreline_density_index\"] <- \"sdi\"\nnames(p8_0)[names(p8_0) == \"snagyn\"] <- \"snag_yn\"\nnames(p8_0)[names(p8_0) == \"sinuosity\"] <- \"sinu\"\n```\n:::\n\n\nWith `dplyr`:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change any column names you want to, all at once\np8_0 <- p8_0 %>% rename(area = Area, \n                perimeter = Perimeter,\n                sdi = shoreline_density_index, \n                snag_yn = snagyn,\n                sinu = sinuosity)\n```\n:::\n\n\nSo pretty. As an added bonus, you’re saved from both quotation marks and the dreaded double equals sign (!!!).\n\nIn case anyone was counting, that’s 102 characters vs. 238 (spaces not included). 116 if you include loading `dplyr`, but you already had it loaded because you’re using it throughout your code, of course.\n\n### Outcome\n\nNow I can rename only the columns I want, by name instead of numerical index, without fear of having to change everything if I insert or delete some columns later on.\n\n### Resources\nMore thoughts on changing individual variable names, including a couple other packages if you feel like trying them:\nhttps://stackoverflow.com/questions/7531868/how-to-rename-a-single-column-in-a-data-frame",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}